import type {
  PrInfo,
  PrMetadata,
  StepResult,
  ReviewOutput,
  ReviewFinding,
  GitHubReviewPayload,
  GitHubReviewComment,
} from "./types.js";
import { truncate } from "./utils.js";

// â”€â”€ Severity icons â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

const SEVERITY_ICON: Record<ReviewFinding["severity"], string> = {
  critical: "ğŸ”´",
  warning: "ğŸŸ¡",
  suggestion: "ğŸ”µ",
  nitpick: "âšª",
};

// â”€â”€ Build inline comment body â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function buildCommentBody(finding: ReviewFinding): string {
  const parts: string[] = [];

  parts.push(`**${SEVERITY_ICON[finding.severity]} ${finding.severity.toUpperCase()}: ${finding.title}**`);
  parts.push("");
  parts.push(finding.body);

  if (finding.suggestion) {
    parts.push("");
    parts.push("```suggestion");
    parts.push(finding.suggestion);
    parts.push("```");
  }

  return parts.join("\n");
}

// â”€â”€ Build summary body â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function buildSummaryBody(
  review: ReviewOutput,
  testResult: StepResult | null,
  lintResult: StepResult | null,
): string {
  const parts: string[] = [];

  parts.push("## PR Review Summary");
  parts.push("");
  parts.push(review.summary);
  parts.push("");

  // Findings overview
  if (review.findings.length > 0) {
    const counts = {
      critical: 0,
      warning: 0,
      suggestion: 0,
      nitpick: 0,
    };
    for (const f of review.findings) {
      counts[f.severity]++;
    }

    parts.push("### Findings");
    parts.push("");
    parts.push("| Severity | Count |");
    parts.push("|----------|-------|");
    if (counts.critical > 0)
      parts.push(`| ${SEVERITY_ICON.critical} Critical | ${counts.critical} |`);
    if (counts.warning > 0)
      parts.push(`| ${SEVERITY_ICON.warning} Warning | ${counts.warning} |`);
    if (counts.suggestion > 0)
      parts.push(`| ${SEVERITY_ICON.suggestion} Suggestion | ${counts.suggestion} |`);
    if (counts.nitpick > 0)
      parts.push(`| ${SEVERITY_ICON.nitpick} Nitpick | ${counts.nitpick} |`);
    parts.push("");
  } else {
    parts.push("No specific code findings.");
    parts.push("");
  }

  // Test results
  if (testResult) {
    const icon = testResult.success ? "âœ…" : "âŒ";
    parts.push(`### Tests ${icon}`);
    parts.push("");
    if (testResult.output === "No test command detected; skipped.") {
      parts.push("_No test command detected._");
    } else {
      parts.push(
        testResult.success
          ? `Tests passed in ${(testResult.duration / 1000).toFixed(1)}s.`
          : `Tests **failed** after ${(testResult.duration / 1000).toFixed(1)}s.`,
      );
      if (!testResult.success) {
        parts.push("");
        parts.push("<details><summary>Test output</summary>");
        parts.push("");
        parts.push("```");
        parts.push(truncate(testResult.output, 3000));
        parts.push("```");
        parts.push("");
        parts.push("</details>");
      }
    }
    parts.push("");
  }

  // Lint results
  if (lintResult) {
    const icon = lintResult.success ? "âœ…" : "âš ï¸";
    parts.push(`### Linting ${icon}`);
    parts.push("");
    if (lintResult.output === "No lint command detected; skipped.") {
      parts.push("_No lint command detected._");
    } else {
      parts.push(
        lintResult.success
          ? `Linting passed in ${(lintResult.duration / 1000).toFixed(1)}s.`
          : `Linter reported issues after ${(lintResult.duration / 1000).toFixed(1)}s.`,
      );
      if (!lintResult.success) {
        parts.push("");
        parts.push("<details><summary>Lint output</summary>");
        parts.push("");
        parts.push("```");
        parts.push(truncate(lintResult.output, 3000));
        parts.push("```");
        parts.push("");
        parts.push("</details>");
      }
    }
    parts.push("");
  }

  parts.push("---");
  parts.push("_Review generated by [pr-reviewer](https://github.com/pr-reviewer) using OpenAI Codex CLI._");

  return parts.join("\n");
}

// â”€â”€ Map verdict â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function mapVerdict(
  verdict: ReviewOutput["verdict"],
): GitHubReviewPayload["event"] {
  switch (verdict) {
    case "approve":
      return "APPROVE";
    case "request_changes":
      return "REQUEST_CHANGES";
    case "comment":
    default:
      return "COMMENT";
  }
}

// â”€â”€ Build review payload â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

/**
 * Build the full GitHub review payload from Codex review output
 * and test/lint results.
 */
export function buildReviewPayload(
  review: ReviewOutput,
  meta: PrMetadata,
  testResult: StepResult | null,
  lintResult: StepResult | null,
): GitHubReviewPayload {
  // Build the summary body
  const body = buildSummaryBody(review, testResult, lintResult);

  // Build inline comments from findings
  // Only include findings for files that are actually part of the PR
  const prFilePaths = new Set(meta.files.map((f) => f.path));
  const comments: GitHubReviewComment[] = [];

  for (const finding of review.findings) {
    // Only add inline comments for files in the PR diff
    if (!prFilePaths.has(finding.file)) {
      continue;
    }

    // Ensure line number is positive
    if (finding.line < 1) {
      continue;
    }

    comments.push({
      path: finding.file,
      line: finding.line,
      body: buildCommentBody(finding),
    });
  }

  return {
    event: mapVerdict(review.verdict),
    body,
    comments,
  };
}
